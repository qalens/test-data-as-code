import {createAsyncThunk, createSlice, PayloadAction} from "@reduxjs/toolkit";
import {addTodo, AddTodoItem, patchTodo, refreshItems} from "./todoAPI";
import {refreshItems as refreshTags} from "../tag/tagAPI";
import {RootState} from "../../app/store";
import { stat } from "fs";
import { iteratorSymbol, objectTraps } from "immer/dist/internal";
import { TagItem } from "../tag/tagSlice";

export enum TodoStatus{
    Active="Active",
    Done="Done"
}
export interface TodoItem{
    id:number,
    name:string,
    tags:number[],
    status:TodoStatus
}
export interface TodoState {
    items?: TodoItem[];
    status: 'idle' | 'loading' | 'failed';
}

const initialState: TodoState = {
    status: 'idle',
};
export const refreshAsync = createAsyncThunk(
    'todo/refresh',
    async (items?: TodoWithTagDetails[]) => {
        if (items){
            return undefined;
        } else {
            return await refreshItems();
        }        
    }
);
export const addAsync = createAsyncThunk(
    'todo/add',
    async (item: AddTodoItem) => {
        await addTodo(item);
        const response =  await refreshItems();
        return response;
    }
);
export const archiveAsync = createAsyncThunk(
    'todo/archive',
    async (id:number) => {
        await patchTodo(id,{status:TodoStatus.Done});
        const response =  await refreshItems();
        return response;
    }
);
export const todoSlice = createSlice({
    name: 'todo',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        // Use the PayloadAction type to declare the contents of `action.payload`
        refresh: (state, action: PayloadAction<TodoItem[]>) => {
            state.items = action.payload;
        },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
            .addCase(refreshAsync.pending, (state) => {
                state.status = 'loading';
            })
            .addCase(refreshAsync.fulfilled, (state, action) => {
                state.status = 'idle';
                if (action.payload)
                    state.items = action.payload;
            })
            .addCase(addAsync.pending, (state) => {
                state.status = 'loading';
            })
            .addCase(addAsync.fulfilled, (state, action) => {
                state.status = 'idle';
                state.items = action.payload
            })
            .addCase(archiveAsync.pending, (state) => {
                state.status = 'loading';
            })
            .addCase(archiveAsync.fulfilled, (state, action) => {
                state.status = 'idle';
                state.items = action.payload
            });
        }
});
export interface TodoWithTagDetails{
    id:number,
    name:string,
    tags:TagItem[],
    status:TodoStatus
}
// export const selectTodos = (state: RootState) => state.todo.items;
export const selectTodos = (state: RootState) :TodoWithTagDetails[]|undefined=> state.todo.items?.map(item=>{
    const tagMapper = (tag:number)=>{
        let found = state.tag.items.find(st=>st.id == tag)
        if(!found){
            found = {"id":tag,"name":"Data Unavailable"}
        }
        return found
    };
    const tags = item.tags.map(tagMapper)
    console.log(tags)
    return {id:item.id,name:item.name,status:item.status,tags}});
export default todoSlice.reducer;